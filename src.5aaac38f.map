{"version":3,"sources":["Field.ts","Game.ts","Player.ts","Piece.ts","index.ts"],"names":[],"mappings":"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","file":"src.5aaac38f.map","sourceRoot":"..\\src","sourcesContent":["import { IPiece } from './Piece';\r\nimport { IPlayer, IPosition } from './Player';\r\n\r\nexport interface IField {\r\n  width: number;\r\n  height: number;\r\n  matrix: number[][];\r\n\r\n  clear(): void;\r\n  collides(piece: IPiece, position: IPosition): boolean;\r\n  merge(piece: IPiece, position: IPosition): void;\r\n  sweep(player: IPlayer): void;\r\n}\r\n\r\nclass Field implements IField {\r\n  public matrix: number[][];\r\n  constructor(public width: number, public height: number) {\r\n    const matrix = [];\r\n    while (height--) { matrix.push(new Array(width).fill(0)); }\r\n    this.matrix = matrix;\r\n  }\r\n\r\n  public clear = (): void => {\r\n    this.matrix.forEach((row) => row.fill(0));\r\n  }\r\n\r\n  public collides = (piece: IPiece, position: IPosition): boolean => {\r\n    return piece.matrix.some((row: number[], y: number) => row.some((cell: number, x: number) =>\r\n      cell && (this.matrix[y + position.y] && this.matrix[y + position.y][x + position.x]) !== 0));\r\n  }\r\n\r\n  public merge = (piece: IPiece, position: IPosition): void => {\r\n    piece.matrix.forEach((row: number[], y: number) => {\r\n      row.forEach((cell: number, x: number) => {\r\n        if (cell) this.matrix[y + position.y][x + position.x] = cell;\r\n      });\r\n    });\r\n  }\r\n\r\n  public sweep = (player: IPlayer): void => {\r\n    let rowCount = 1;\r\n\r\n    for (let y = this.matrix.length - 1; y > 0; y--) {\r\n      if (this.matrix[y].every((cell: number) => cell !== 0)) {\r\n        const row = this.matrix.splice(y, 1)[0].fill(0);\r\n        this.matrix.unshift(row);\r\n        y += 1;\r\n\r\n        player.score += rowCount * 10;\r\n        rowCount *= 2;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Field;\r\n","import { IField } from './Field';\r\nimport { IPlayer, IPosition } from './Player';\r\n\r\nexport interface IGame {\r\n  context: CanvasRenderingContext2D;\r\n  player: IPlayer;\r\n  field: IField;\r\n\r\n  run(time?: number): void;\r\n}\r\n\r\nconst colors = [\r\n  null,\r\n  '#e5282e',\r\n  '#f8d517',\r\n  '#df2384',\r\n  '#274696',\r\n  '#ef7e18',\r\n  '#5cad2c',\r\n  '#2cb099',\r\n];\r\n\r\nclass Game implements IGame {\r\n  public static dropInterval: number = 1000;\r\n  private lastTime: number = 0;\r\n  constructor(\r\n    public context: CanvasRenderingContext2D,\r\n    public player: IPlayer,\r\n    public field: IField,\r\n  ) {\r\n    player.game = this;\r\n    player.reset();\r\n    player.updateScore();\r\n  }\r\n\r\n  public run = (time: number = 0): void => {\r\n    const deltaTime: number = time - this.lastTime;\r\n    this.lastTime = time;\r\n\r\n    this.player.dropCounter += deltaTime;\r\n    if (this.player.dropCounter > Game.dropInterval) {\r\n      this.player.drop();\r\n    }\r\n\r\n    this.draw();\r\n    requestAnimationFrame(this.run);\r\n  }\r\n\r\n  private draw = (): void => {\r\n    this.context.fillStyle = '#000';\r\n    this.context.fillRect(0, 0, this.context.canvas.width, this.context.canvas.height);\r\n    this.drawMatrix(this.field.matrix, { x: 0, y: 0 });\r\n    this.drawMatrix(this.player.piece.matrix, this.player.position);\r\n  }\r\n\r\n  private drawMatrix = (matrix: number[][], position: IPosition): void => {\r\n    matrix.forEach((row: number[], y: number) => {\r\n      row.forEach((cell: number, x: number) => {\r\n        if (cell) {\r\n          this.context.fillStyle = colors[cell];\r\n          this.context.fillRect(x + position.x, y + position.y, 1, 1);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nexport default Game;\r\n","import { IGame } from './Game';\r\nimport { IPiece } from './Piece';\r\n\r\nexport interface IPosition {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface IPlayer {\r\n  game: IGame;\r\n  piece: IPiece;\r\n  position: IPosition;\r\n  dropCounter: number;\r\n  score: number;\r\n\r\n  drop(): void;\r\n  inputController(e: KeyboardEvent): void;\r\n  reset(): void;\r\n  updateScore(): void;\r\n}\r\n\r\nexport const enum Direction {\r\n  Left = -1,\r\n  Right = 1,\r\n}\r\n\r\nexport const enum KeyCode {\r\n  Space = 32,\r\n  Left = 37,\r\n  Up,\r\n  Right,\r\n  Down,\r\n  W = 87,\r\n  A = 65,\r\n  S = 83,\r\n  D = 68,\r\n}\r\n\r\nclass Player implements IPlayer {\r\n  public dropCounter: number = 0;\r\n  public game: IGame;\r\n  public position: IPosition = { x: 0, y: 0 };\r\n  public score: number = 0;\r\n\r\n  constructor(public piece: IPiece) {}\r\n\r\n  public drop = (): void => {\r\n    this.position.y += 1;\r\n    if (this.game.field.collides(this.piece, this.position)) {\r\n      this.position.y -= 1;\r\n      this.game.field.merge(this.piece, this.position);\r\n      this.reset();\r\n      this.game.field.sweep(this);\r\n      this.updateScore();\r\n    }\r\n    this.dropCounter = 0;\r\n  }\r\n\r\n  public inputController = (e: KeyboardEvent): void => {\r\n    switch (e.keyCode) {\r\n      case KeyCode.Left:\r\n      case KeyCode.A:\r\n        this.move(Direction.Left);\r\n        break;\r\n\r\n      case KeyCode.Right:\r\n      case KeyCode.D:\r\n        this.move(Direction.Right);\r\n        break;\r\n\r\n      case KeyCode.Down:\r\n      case KeyCode.S:\r\n        this.drop();\r\n        break;\r\n\r\n      case KeyCode.Up:\r\n      case KeyCode.W:\r\n      case KeyCode.Space:\r\n        this.rotate();\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  public reset = () => {\r\n    const type = Math.floor(this.piece.typesCount * Math.random());\r\n    this.piece.matrix = this.piece.createMatrix(type);\r\n\r\n    this.position.y = 0;\r\n    this.position.x = Math.floor(this.game.field.width / 2) - Math.floor(this.piece.matrix.length / 2);\r\n\r\n    if (this.game.field.collides(this.piece, this.position)) {\r\n      this.game.field.clear();\r\n      this.score = 0;\r\n      this.updateScore();\r\n    }\r\n  }\r\n\r\n  public updateScore = (): void =>  {\r\n    document.getElementById('score').innerText = `Score: ${this.score}`;\r\n  }\r\n\r\n  private move = (direction: Direction): void => {\r\n    this.position.x += direction;\r\n    if (this.game.field.collides(this.piece, this.position)) this.position.x -= direction;\r\n  }\r\n\r\n  private rotate = (): void => {\r\n    const initialX = this.position.x;\r\n    let offset: number = 1;\r\n    this.piece.rotate(Direction.Right);\r\n\r\n    while (this.game.field.collides(this.piece, this.position)) {\r\n      this.position.x += offset;\r\n      offset = -(offset > 0 ? offset + 1 : offset - 1);\r\n\r\n      if (offset > this.piece.matrix.length) {\r\n        this.piece.rotate(Direction.Left);\r\n        this.position.x = initialX;\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default Player;\r\n","import { Direction } from './Player';\r\n\r\nexport interface IPiece {\r\n  matrix: number[][];\r\n  type: Type;\r\n  typesCount: number;\r\n\r\n  createMatrix(type: Type): number[][];\r\n  rotate(direction: Direction): void;\r\n}\r\n\r\nexport enum Type {\r\n  I = 0, J, L, O, S, T, Z,\r\n}\r\n\r\nclass Piece implements IPiece {\r\n  public type: Type;\r\n  public matrix: number[][];\r\n  public get typesCount() {\r\n    return Object.keys(Type).length / 2;\r\n  }\r\n\r\n  constructor() {\r\n    this.type = Math.floor(this.typesCount * Math.random());\r\n    this.matrix = this.createMatrix(this.type);\r\n  }\r\n\r\n  public createMatrix = (type: Type): number[][] => {\r\n    switch (type) {\r\n      case Type.I:\r\n        return [\r\n          [0, 1, 0, 0],\r\n          [0, 1, 0, 0],\r\n          [0, 1, 0, 0],\r\n          [0, 1, 0, 0],\r\n        ];\r\n\r\n      case Type.J:\r\n        return [\r\n          [0, 2, 0],\r\n          [0, 2, 0],\r\n          [2, 2, 0],\r\n        ];\r\n\r\n      case Type.L:\r\n        return [\r\n          [0, 3, 0],\r\n          [0, 3, 0],\r\n          [0, 3, 3],\r\n        ];\r\n\r\n      case Type.O:\r\n      default:\r\n        return [\r\n          [4, 4],\r\n          [4, 4],\r\n        ];\r\n\r\n      case Type.S:\r\n        return [\r\n          [0, 5, 5],\r\n          [5, 5, 0],\r\n          [0, 0, 0],\r\n        ];\r\n\r\n      case Type.T:\r\n        return [\r\n          [6, 6, 6],\r\n          [0, 6, 0],\r\n          [0, 0, 0],\r\n        ];\r\n\r\n      case Type.Z:\r\n        return [\r\n          [7, 7, 0],\r\n          [0, 7, 7],\r\n          [0, 0, 0],\r\n        ];\r\n    }\r\n  }\r\n\r\n  public rotate = (direction: Direction = Direction.Right): void => {\r\n    for (let y = 0; y < this.matrix.length; y++) {\r\n      for (let x = 0; x < y; x++) {\r\n        [this.matrix[x][y], this.matrix[y][x]] = [this.matrix[y][x], this.matrix[x][y]];\r\n      }\r\n    }\r\n\r\n    if (direction === Direction.Right) {\r\n      this.matrix.forEach((row) => row.reverse());\r\n    } else {\r\n      this.matrix.reverse();\r\n    }\r\n  }\r\n}\r\n\r\nexport default Piece;\r\n","import Field, { IField } from './Field';\r\nimport Game, { IGame } from './Game';\r\nimport Piece from './Piece';\r\nimport Player, { IPlayer } from './Player';\r\n\r\nconst canvas: HTMLCanvasElement = document.getElementById('tetris') as HTMLCanvasElement;\r\nexport const context: CanvasRenderingContext2D = canvas.getContext('2d');\r\n\r\ncontext.scale(20, 20);\r\n\r\nconst field: IField = new Field(12, 20);\r\nconst player: IPlayer = new Player(new Piece());\r\nconst game: IGame = new Game(context, player, field);\r\n\r\ndocument.addEventListener('keydown', player.inputController);\r\ngame.run();\r\n"]}